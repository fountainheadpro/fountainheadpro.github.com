---
layout: post
title: "Domain Specific Language For Build ← Measure ← Learn"
description: "Iterating on abstractions"
category: 
tags: [architecture, iteration, modelling]
---
{% include JB/setup %}


A lot been said about the necessity of rapid iteration process, which will support Build - Measure - Learn cycle.
<div><img src='/assets/images/feedback-loop.png' width='50%'/></div>
Many times, I heard about the necessity of lean software development process. Big design upfront will not enable fast iterative process focused around the customer.


At the same time, it's hard to overestimate the importance of the right software abstractions.

Here is what MIT Professor Daniel Jackson has to say about it.
>Pick the right ones, and programming will flow naturally from design; modules will have small and simple interfaces; and new functionality will more likely fit in without extensive reorganization. Pick the wrong ones, and programming will be a series of nasty surprises: interfaces will become baroque and clumsy as they are forced to accommodate unanticipated interactions, and even the simplest of changes will be hard to make. <a  target="_blank" href='http://www.quora.com/Software-Engineering/What-makes-a-good-engineering-culture/answer/Edmond-Lau'>Quora: What makes a good engineering culture?</a> 

This post will describe the process for iterative development, which will also help zero down to the right abstractions.

# Battlefield

Building new the software project is different. You do not really see you each goal.
Like Bruce Lee in the movie Enter the Dragon, you see only your own image in the room of mirrors.
<img src='/assets/images/bruce_lee_mirrors.jpg' width='100%'/>
All you see is the reflection of the ideas your team has. 

How do you start building the model, while 

# Find core functionality you will iterate on
You will need to find which functionality you will be iterating the most.




# Implement your functionality in your language




# Implement your DSL



